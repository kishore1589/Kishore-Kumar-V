/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f405xx.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


/******PROCEDURE************/
/* Step 1: Identify the bus clock , APB1 bus (UART4), AHB1 (PORTA)*/
/*Step 2: Config PORTA for UART4 PA0-> TX, PA1->RX*/
/* 2.1-> Select Mode of operation for PA0 & PA1 as alternate fn*/
/* 2.2-> AFRL alternate function as AF8 (PA0 & PA1)*/
/*2.4-> select speed as high speed in PA0 & PA1*/
/*Step 3: config UART*/

uint8_t rx_data;

void UART4_config()
{
	/*UART port pin config*/
	RCC->AHB1ENR |= (1<<0);			// enable GPIOA clock
	GPIOA->MODER &= ~(0xF<<0);		// enable alternate fn in PA0 & 1
	GPIOA->MODER |=(0xA<<0);
	GPIOA->AFR[0] &= ~(0xFF<<0);	// enable UART4 TX & RX function for PA0 & PA1(62 - data sheet)
	GPIOA->AFR[0] |= (0x88<<0);
	GPIOA->OSPEEDR |= (0xF<<0);		// set output speed as high speed
	/*UART4 config */
	RCC->APB1ENR |= (1<<19); 		// enable UART4 clock
	UART4->CR1 |= (1<<13); 			//Uart4 is enabled ( 1010 - ref manual)
	UART4->CR1 &= ~(1<<12); 		//set 8bit data mode
 	UART4->BRR = 0x683;				// baudrate for 9600
	UART4->CR1 |= (3<<2); 			// TE & RE enable ( 1010 - ref manual)
}

void UART4_sendchar(uint8_t x)
{
	UART4->DR = x;						/*Please the data in DR register for transmitting*/
	while(!(UART4->SR & (1<<6)));		/*Wait until TC (Transmission complete) is 1*/
}

void UART4_receivechar(void)
{
	while(!(UART4->SR & (1<<5)));		/*wait until RXNE bit is set which indicates data receive*/
	rx_data=UART4->DR;				// read RX data and store in variable
}
void led_config()
{
	RCC->AHB1ENR |= (1<<2);			// Enable clock for GPIOC
	GPIOC->MODER &= ~(3<<12);		// Set PC6 as Output Mode
	GPIOC->MODER |= (1<<12);
	GPIOC->OTYPER &= ~(1<<6);		// PC6 as push pull output
	GPIOC->OSPEEDR &= ~(3<<12);		// PC6 as low speed
	GPIOC->ODR |= (1<<6);			// LED OFF
}

void check_ledstatus()
{
	if(rx_data=='1')				// if '1' receive LED ON
	{
		GPIOC->ODR &= ~(1<<6);
	}
	else if (rx_data=='0')			// if '0' receive LED OFF
	{
		GPIOC->ODR |= (1<<6);
	}
}

int main(void)
{
	UART4_config();
	led_config();
	for(;;)
	{
		UART4_sendchar('1');
		UART4_receivechar();
		check_ledstatus();
		for(uint32_t delay=0;delay<200000;delay++ );
		UART4_sendchar('0');
		UART4_receivechar();
		check_ledstatus();
		for(uint32_t delay=0;delay<200000;delay++ );
	}
}
